//go:generate go run main.go

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"gopkg.in/yaml.v3"
)

// command flag arguments
var (
	inputPath   = flag.String("in", "../et/et.yaml", "Path to input YAML file")
	outputPath  = flag.String("out", "../locales-keys.go", "Path to output Go file")
	packageName = flag.String("pkg", "locales", "Package name for the generated file")
	enumPrefix  = flag.String("pfx", "LK", "Prefix for the locale enum also used as enum type")
)

var (
	// used to capitalize variable names
	caser = cases.Title(language.BritishEnglish)
	// used to sanitize yaml key path for use as golang variable names
	rgxVarSanitizer = regexp.MustCompile("[-_]")
)

func main() {
	flag.Parse()

	entries, entryKeys := parseLocaleYml()
	buffer := generateOutputContent(entries, entryKeys)
	writeOutput(buffer)
}

// returns entries and keys used to access them in a sorted order
func parseLocaleYml() (map[string]string, []string) {
	log.Println("parsing locale structure from ", strconv.Quote(*inputPath))

	data, err := os.ReadFile(*inputPath)
	if err != nil {
		log.Fatalf("FAILED to read input file: %v", err)
	}

	var parsed map[string]any
	if err := yaml.Unmarshal(data, &parsed); err != nil {
		log.Fatalf("FAILED to parse YAML: %v", err)
	}

	entries := make(map[string]string, len(parsed))
	for _, node := range parsed {
		// ignoring top level -- usually the language code like "et"
		flattenYAML(node, []string{}, entries)
	}
	// this to have output more consistent -- do not want git commit when nothing has changed
	entryKeys := make([]string, 0, len(entries))
	for k := range entries {
		entryKeys = append(entryKeys, k)
	}
	sort.Strings(entryKeys)

	return entries, entryKeys
}

func generateOutputContent(entries map[string]string, entryKeys []string) *bytes.Buffer {
	log.Printf("generating locale key content with:\n"+
		"- package: %s\n"+
		"- enum type: %s\n",
		strconv.Quote(*packageName),
		strconv.Quote(*enumPrefix),
	)

	var buf bytes.Buffer
	// up to first enum is like 212 char + 3 char after
	n := 220
	for _, key := range entryKeys {
		// *2 since key should be about the same size as value,
		//  same when value has same amount of .s as the enumPrefix/type
		n += len(key) * 2
	}
	// got the idea to optimize this after looking inside strings.Join
	// is a little bit faster -- biggest diff 1500Î¼s, usually around 200
	// did have to use sleep 1s to see a number other than 0
	buf.Grow(n)
	buf.WriteString("// Code generated by gen-keys - DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", *packageName))

	// write types
	buf.WriteString("// Used to index i18n values\n")
	buf.WriteString(fmt.Sprintf("type %s string\n\n", *enumPrefix))
	buf.WriteString("// Used to pipe key and arguments into ctxi18n\n")
	buf.WriteString(fmt.Sprintf("type %sMessage struct {\n", *enumPrefix))
	buf.WriteString(fmt.Sprintf("	Key  %s\n", *enumPrefix))
	buf.WriteString("	Args []any\n")
	buf.WriteString("}\n\n")

	// write constants
	buf.WriteString("const (\n")
	for _, key := range entryKeys {
		value := entries[key]
		buf.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", key, *enumPrefix, value))
	}
	buf.WriteString(")\n")
	return &buf
}

func writeOutput(buffer *bytes.Buffer) {
	formattedContent, err := format.Source(buffer.Bytes())
	if err != nil {
		log.Fatalf("FAILED to format generated code: %v", err)
	}

	log.Println("writing content to " + strconv.Quote(*outputPath))
	err = os.WriteFile(*outputPath, formattedContent, 0644)
	if err != nil {
		log.Fatalf("FAILED to write \"%s\" file: %v", *outputPath, err)
	}
}

// flattenYAML recursively flattens nested maps into dot-separated keys
func flattenYAML(node any, path []string, out map[string]string) {
	switch v := node.(type) {
	case map[string]any:
		for key, value := range v {
			flattenYAML(value, append(path, key), out)
		}
	default:
		name, value := pathToConst(path)
		out[name] = value

		lastIndex := len(path) - 1
		// it is assumed that when last element is "other" then pluralization
		if path[lastIndex] == "other" {
			parentPath := path[:lastIndex]
			name, value := pathToConst(parentPath)
			out[name] = value
		}
	}
}

// does not check the length of the path, is assumed it is bigger than 0
//
// return
//   - first is the name of the constant
//   - second is the value of the constant, the key for ctxi18n
func pathToConst(path []string) (string, string) {
	var name strings.Builder
	var value strings.Builder

	firstPath := path[0]
	name.WriteString(*enumPrefix + toConstName(firstPath))
	value.WriteString(firstPath)
	for _, p := range path[1:] {
		name.WriteString(toConstName(p))
		value.WriteString("." + p)
	}
	return name.String(), value.String()
}

func toConstName(s string) string {
	// converted string
	cs := caser.String(s)
	cs = rgxVarSanitizer.ReplaceAllString(cs, "")
	return cs
}
