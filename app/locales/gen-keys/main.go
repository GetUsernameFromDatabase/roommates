//go:generate go run main.go

package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"gopkg.in/yaml.v3"
)

// command flag arguments
var (
	inputPath   = flag.String("in", "../et/et.yaml", "Path to input YAML file")
	outputPath  = flag.String("out", "../locales-keys.go", "Path to output Go file")
	packageName = flag.String("pkg", "locales", "Package name for the generated file")
	enumPrefix  = flag.String("pfx", "LK", "Prefix for the locale enum also used as enum type")
)

var (
	// used to capitalize variable names
	caser = cases.Title(language.BritishEnglish)
	// used to sanitize yaml key path for use as golang variable names
	rgxVarSanitizer = regexp.MustCompile("[-_]")
)

func main() {
	flag.Parse()

	entries, entryKeys := parseLocaleYml()
	buffer := generateOutputContent(entries, entryKeys)
	writeOutput(buffer)
}

// returns entries and keys used to access them in a sorted order
func parseLocaleYml() (map[string]string, []string) {
	log.Println("parsing locale structure from ", strconv.Quote(*inputPath))

	data, err := os.ReadFile(*inputPath)
	if err != nil {
		log.Fatalf("FAILED to read input file: %v", err)
	}

	var parsed map[string]any
	if err := yaml.Unmarshal(data, &parsed); err != nil {
		log.Fatalf("FAILED to parse YAML: %v", err)
	}

	entries := make(map[string]string)
	for _, node := range parsed {
		// ignoring top level -- usually the language code like "et"
		flattenYAML(node, "", []string{}, entries)
	}
	// this to have output more consistent -- do not want git commit when nothing has changed
	entryKeys := make([]string, 0, len(entries))
	for k := range entries {
		entryKeys = append(entryKeys, k)
	}
	sort.Strings(entryKeys)

	return entries, entryKeys
}

func generateOutputContent(entries map[string]string, entryKeys []string) *bytes.Buffer {
	log.Printf("generating locale key content with:\n"+
		"- package: %s\n"+
		"- enum type: %s\n",
		strconv.Quote(*packageName),
		strconv.Quote(*enumPrefix),
	)

	var buf bytes.Buffer
	buf.WriteString("// Code generated by gen-keys - DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", *packageName))

	// write types
	buf.WriteString("// Used to index i18n values\n")
	buf.WriteString(fmt.Sprintf("type %s string\n\n", *enumPrefix))
	buf.WriteString("// Used to pipe key and arguments into ctxi18n\n")
	buf.WriteString(fmt.Sprintf("type %sMessage struct {\n", *enumPrefix))
	buf.WriteString(fmt.Sprintf("	Key  %s\n", *enumPrefix))
	buf.WriteString("	Args []any\n")
	buf.WriteString("}\n\n")

	// write constants
	buf.WriteString("const (\n")
	for _, key := range entryKeys {
		value := entries[key]
		buf.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", key, *enumPrefix, value))
	}
	buf.WriteString(")\n")
	return &buf
}

func writeOutput(buffer *bytes.Buffer) {
	log.Println("writing content to " + strconv.Quote(*outputPath))
	err := os.WriteFile(*outputPath, buffer.Bytes(), 0644)
	if err != nil {
		log.Fatalf("FAILED to write \"%s\" file: %v", *outputPath, err)
	}

	// format generated file
	log.Println("formatting generated file with go fmt")
	cmd := exec.Command("go", "fmt", *outputPath)
	err = cmd.Run()
	if err != nil {
		log.Fatalf("FAILED to format \"%s\": %v", *outputPath, err)
	}
}

// flattenYAML recursively flattens nested maps into dot-separated keys
func flattenYAML(node any, prefix string, path []string, out map[string]string) {
	switch v := node.(type) {
	case map[string]any:
		for key, value := range v {
			flattenYAML(value, prefix, append(path, key), out)
		}
	default:
		if prefix != "" {
			path = append([]string{prefix}, path...)
		}

		enumName := *enumPrefix + pathToVariableName(path)
		fullPath := strings.Join(path, ".")
		out[enumName] = fullPath
	}
}

func pathToVariableName(path []string) string {
	var b strings.Builder
	for _, part := range path {
		str := caser.String(part)
		str = rgxVarSanitizer.ReplaceAllString(str, "")
		b.WriteString(str)
	}
	return b.String()
}
